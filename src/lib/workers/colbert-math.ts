import { inner } from "simsimd";

export function maxSim(
  queryEmbeddings: number[][] | Float32Array[],
  docEmbeddings: number[][] | Float32Array[],
): number {
  if (queryEmbeddings.length === 0 || docEmbeddings.length === 0) {
    return 0;
  }

  const qVecs = queryEmbeddings.map((v) =>
    v instanceof Float32Array ? v : new Float32Array(v),
  );
  const dVecs = docEmbeddings.map((v) =>
    v instanceof Float32Array ? v : new Float32Array(v),
  );

  let totalScore = 0;
  for (const qVec of qVecs) {
    let maxDotProduct = -Infinity;
    for (const dVec of dVecs) {
      const dim = Math.min(qVec.length, dVec.length);
      const dot = inner(qVec.subarray(0, dim), dVec.subarray(0, dim));
      if (dot > maxDotProduct) maxDotProduct = dot;
    }
    totalScore += maxDotProduct;
  }

  return totalScore;
}

export function cosineSim(
  a: number[] | Float32Array,
  b: number[] | Float32Array,
): number {
  const aVec = a instanceof Float32Array ? a : new Float32Array(a);
  const bVec = b instanceof Float32Array ? b : new Float32Array(b);

  const dim = Math.min(aVec.length, bVec.length);
  if (aVec.length !== bVec.length) {
    return inner(aVec.subarray(0, dim), bVec.subarray(0, dim));
  }
  return inner(aVec, bVec);
}
